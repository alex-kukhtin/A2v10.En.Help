<div>
	<!--title:Hierarchical data models-->
	<!--keywords:Hierarchical data models;-->
	<div class="title">
		<h1>
			Hierarchical data models
		</h1>
		<div class="breadcrumb">
			<a href="index">Data models</a>
		</div>
	</div>
	<p>
		The hierarchical (tree-like) data model includes a set of records 
		with a parent-child relationship. The nesting depth is not limited.
	</p>

	<p>
		The hierarchical model is represented by the <code>!Tree</code> object type.
		For the tree to work properly, each record must have three required fields:
	</p>
	<ul class="std">
		<li><code>!Id</code> - record identifier</li>
		<li><code>!ParentId</code> - parent record identifier.</li>
		<li><code>!Items</code> - an array of child fields.</li>
	</ul>

	<p class="tip info">
		<b>Note</b>. The T-SQL recursive query engine (CTE) - Common Table Expressions
		and the WITH clause - is usually used to generate record sets.
		<a target="_blank" rel="noopener" href="https://docs.microsoft.com/ru-ru/sql/t-sql/queries/with-common-table-expression-transact-sql?view=sql-server-ver15">For more information, see the Microsoft documentation</a>.
	</p>

	<p>
		The trees can be loaded both statically (the entire tree in one request), and 
		dynamically (lazy loading), when the branches of the tree are filled from the
		database only in case the user (or program) expands this branch.
	</p>

	<h3>Example</h3>
	<p>
		Working with a hierarchical model is easiest to demonstrate with an example. Let
		there be a table <code>Agents</code> of the following form:
	</p>

	<table class="sql-table">
		<thead>
			<tr>
				<th>Id</th>
				<th>Parent</th>
				<th>Name</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="text-right">10</td>
				<td class="text-right">null</td>
				<td>Agent 1</td>
			</tr>
			<tr>
				<td class="text-right">20</td>
				<td class="text-right">null</td>
				<td>Agent 2</td>
			</tr>
			<tr>
				<td class="text-right">100</td>
				<td class="text-right">10</td>
				<td>Subagent 1.1</td>
			</tr>
			<tr>
				<td>110</td>
				<td class="text-right">10</td>
				<td>Subagent 1.2</td>
			</tr>
			<tr>
				<td>200</td>
				<td class="text-right">20</td>
				<td>Subagent 2.1</td>
			</tr>
			<tr>
				<td>210</td>
				<td class="text-right">20</td>
				<td>Subagent 2.2</td>
			</tr>
		</tbody>
	</table>

	<h3>Static tree</h3>
	<p>
		The static tree is completely filled at once in one access to the database. 
		The query that generates data for the tree model will look as follows:
	</p>

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
create or alter procedure dbo.[Agent.Index.Load]
@UserId bigint
as
begin
set nocount on;
with T(Id, Parent, [Level])
as (
	select Id, Parent, 0 from dbo.Agents a where a.Parent is null
	union all
	select a.Id, a.Parent, T.[Level] + 1
	from dbo.Agents a inner join T on T.Id = a.Parent
)
select [Agents!TAgent!Tree] = null, [Id!!Id] = a.Id, [Name!!Name] = a.[Name],
	[!TAgent.Items!ParentId]=T.Parent, [Items!TAgent!Items] = null, [Level] = T.[Level]
from dbo.Agents a inner join T on  a.Id = T.Id
order by [Level], [Id!!Id];
end
</script>
</pre>

<p>
	When this set is being processed, a simple array of <code>Agents</code>  items of <code>TAgent</code>
	type is created. Each item of this array will contain an <code>Items</code> array that will be
	populated with child items. The parent item is defined by the property with the <code>ParentId</code>.
	modifier. Note that this field does not have a property name, so it will not be included in the resulting model.
</p>

	<p>В результате обработки получится вот такая модель (служебные свойства для простоты не показаны):</p>
<pre class="code-highlight js" data-lang="js">
	<script type="text/template">{
  "Agents": [
    {
      "Id": 10,
      "Name": "Agent1",
      "Items": [
        {
          "Id": 100,
          "Name": "Subagent 1.1",
          "Items": [],
          "Level": 1,
        },
        {
          "Id": 101,
          "Name": "Subagent 1.2",
          "Items": [],
          "Level": 1,
        }
      ],
      "Level": 0,
    },
    {
      "Id": 20,
      "Name": "Agent2",
      "Items": [
        {
          "Id": 200,
          "Name": "Subagent 2.1",
          "Items": [],
          "Level": 1,
        },
        {
          "Id": 201,
          "Name": "Subagent 2.2",
          "Items": [],
          "Level": 1,
        }
      ],
      "Level": 0,
    }
  ]
}</script>
</pre>

	<p>
		Для работы с такой моделью чаще всего используется элемент
		управления <a href="/xaml/controls/treeview">TreeView</a>.
	</p>

	<p>Например (XAML):</p>
<pre class="code-highlight xml">
	<script type="text/template">
<![CDATA[
<TreeView ItemsSource="{Bind Agents}" IconFolder="Folder" IconItem="File">
	<TreeViewItem ItemsSource="{Bind Items}" Label="{Bind Name}" />
</TreeView>
]]>
	</script>
</pre>

	<h3>Динамическое дерево</h3>
	<p>Динамическое дерево заполняется по мере того, как пользователь открывает определенные ветви дерева.</p>
	<p>
		При работе с динамическим деревом достаточно вернуть из процедуры загрузки только верхний уровень дерева.
		Однако для того, чтобы система знала, какие элементы можно раскрыть, нужно иметь в модели еще одно служебное
		свойство с специальным типом <code>!HasChildren</code>. Если такое свойство установлено, то система считает, что этот
		элемент имеет дочерние и показывает соответствующие элементы пользовательского интерфейса.
	</p>
	<p>
		Обратите внимание,
		что такое свойство, несмотря на то, что оно служебное, обязательно должно иметь имя, поскольку работа с ним ведется на
		клиентской стороне.
	</p>

	<p>
		Когда пользователь пытается раскрыть такой элемент дерева, вызывается хранимая процедура с суффиксом
		<code>.Expand</code>, которая должна вернуть дочерние элементы для этого узла.
		Далее процесс повторяется рекурсивно.
	</p>

	<p>Процедура верхнего уровня может вернуть такой набор:</p>
<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
create or alter procedure dbo.[Agent.Index.Load]
@UserId bigint
as
begin
set nocount on;
	select [Agents!TAgent!Tree] = null, [Id!!Id] = a.Id, [Name!!Name] = a.[Name],
		[Items!TAgent!Items] = null,
		[HasChildren!!HasChildren] = case when exists(select * from dbo.Agents c where c.Parent = a.Id) then 1 else 0 end
	from dbo.Agents a where Parent is null
	order by [Id!!Id];
end
</script>
</pre>

	<p>
		Тогда при попытке раскрытия дерева вызовется процедура <code>.Expand</code>, которая должна вернуть
		элементы следующего уровня дерева.
	</p>

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
create or alter procedure dbo.[Agent.Index.Expand]
@UserId bigint,
@Id bigint
as
begin
set nocount on;
/*обратите внимание, что теперь дерево имеет имя Items (такое-же как и дочерние элементы верхнего уровня) */
select [Items!TAgent!Tree] = null, [Id!!Id] = a.Id, [Name!!Name] = a.[Name],
	[Items!TAgent!Items] = null,
	[HasChildren!!HasChildren] = case when exists(select * from dbo.Agents c where c.Parent = a.Id) then 1 else 0 end
from dbo.Agents a where Parent = @Id
order by [Id!!Id];
end
</script>
</pre>

	<p>
		Элементы дерева в модели данных реализуют интерфейс <code>ITreeElement</code> и
		имеют некоторые дополнительные свойства. <a href="/client/treeelemprops">Подробнее...</a>.
	</p>

</div>